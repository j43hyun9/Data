#include <stdio.h>

void Hanoi(int num, char from, char by, char to);


int main(void) {
	// 하노이타워의 재귀식에는 "순서"에 대한 표현이 없다.
	// 하노이타워는 "순서" 에 대한 규칙이 존재한다.
	// 일반적으로 점화식상에서 "순서"에 대한 개념이 존재한다면
	// 개념의 부재가 원인이다.
	// 수학에서 피보나치 수열의 경우 재귀적 호출에 순서가
	// 상관이 없다. 그러나 하노이타워의 재귀식의 경우
	// 출력 역할의 print문의 위치에 따라 출력값이
	// 천차 만별 달라진다.
	// feedback
	// 세늘솜 > 재귀에서 순서를 찾는다는거 자체가 부자연스럽다.
	// 재귀를 하는 이유는 재귀로 호출하는 함수가 알아서 해줄거라는
	// 믿음으로 호출한다고 치고 넘어가면 좀 더 자연스럽게 이해된다.
	// Nyan101 > 피보나치는 "값"이 중요하고 하노이탑은 "순서" 를 구하는거니까
	// 세늘솜 > 재귀꼴이라는걸 읽어내는거 자체가 그걸 짤 수 있어야 그런 결론이
	// 나오는거다.
	// ((121)(3)(121))(4)((121)(3)(121)) 구조를 읽고 나야 이게 재귀로 풀린다가 이해될텐데
	// 그러면 f(4)=f(3)+4+f(3)꼴로 재귀되잖아요
	// 즉 f(x) = f(x) + x + f(x)
	// 세늘솜 > 하노이탑 n단계를 풀려면 n번째 판을 옮겨야
	// 한다. 그러면 출발/시작 기둥이
	// 나머지 n-1개는 나머지 기둥에 이동해있는데
	// 이것이 n-1단계를 푸는 과정과 동일하다.
	// 3단계를 풀려면 3번쨰 판을 옮겨야한다
	// 그러기 위해 2개는 나머지 기둥에 이동하는데
	// 이것이 2단계를 푸는 과정과 동일하다.  
	// ANZ > 자꾸 전체 하노이탑 옮기는 수열만 보고
	// 이걸 재귀로 만들어야지 하시는거같은데
	// 이 수열은 아무 의미가 없다.
	// 결과를 보고 함수를 짜맞출라고 하면
	// 당연히 아무도 못한다.
	// 일반항 자체는 특수한 케이스이다.
	// 하노이탑은 일반항이 잘 정리되는 케이스
	// 나 > 원하는 동작은 출력값으로 인식한다 하면
	// 원하는 동작을 통해 함수의 동작원리를 추론해내는게 알고리즘의 핵심 아닌가요 ? ?
	// 재귀함수는 이런 접근방식으로 하면 안되는건가요 ?
	// AND > 출력값을 보고 알고리즘을 추론하는 걸 사람이 어케함
	// 세늘솜 > 출력을 보고 원리를 파악하는 건 순서가 반대이다.
	// 즉, 원리를 알고 출력을 알게되는게 보통

	Hanoi(5, 'A', 'B', 'C');
	return 0;
}

void Hanoi(int num, char from, char by, char to) {
	if (num == 1) {
		printf("%d %c %c\n",1, from, to);
		return;
	}
	Hanoi(num - 1, from, to, by);        // 원판 n-1개를 A에서 B로 옮겨준다.
	printf("%d %c %c\n", num, from, to); // n-1개가 옮겨졌으니 n번쨰 원반을 옮겨준다.
	Hanoi(num - 1, by, to, from);        // n-1개 원판을 다시 옮겨준다.
}